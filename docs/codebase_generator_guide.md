# Codebase Generator Guide

**IMPORTANT**: This document is a work in progress and may contain incomplete or outdated information. It was generated by an AI assistant and may not be accurate. The content of `recipes/codebase_generator` are the _official_ documentation for the Codebase Generator recipes for Recipe Extractor. Please refer to those files for the most accurate and up-to-date information. For a more complete, up-to-date artifact to share with AI assistants, please use the `ai_context/generated/codebase_generator_*.md` files.

## Overview

The Codebase Generator is a specialized application of the Recipe Executor tool that focuses specifically on generating complete codebases from specifications. It uses a modular, recipe-driven approach to software development where AI handles the code construction while humans focus on architecture and quality assurance. This document explains how the Codebase Generator works and how you can use it to develop your own software projects.

## Key Concepts

### The Recipe-Driven Development Approach

The Codebase Generator embodies a development philosophy described in the "Building Software with AI: A Modular Block Approach" document:

> Imagine those interlocking bricks could assemble themselves whenever you gave them the right instructions. This is the essence of our new AI-driven software development approach: **we provide the blueprint, and AI builds the product, one modular piece at a time.**

This approach treats code not as something to edit line-by-line, but as something to describe and let the AI generate. Each component is treated as a self-contained "brick" of functionality with defined interfaces to the rest of the system.

### Component-Based Architecture

The Codebase Generator organizes software into distinct components, each with:

1. A specification document (what the component should do)
2. A documentation file (how to use the component)
3. Generated code files (the implementation)

This structure allows for:

- Independent regeneration of components
- Clear separation of concerns
- Maintainable, modular software

## Recipe Structure

The core recipe for generating code is defined in `recipes/codebase_generator/generate_code.json`:

```json
{
  "steps": [
    {
      "type": "read_files",
      "config": {
        "path": "ai_context/IMPLEMENTATION_PHILOSOPHY.md",
        "content_key": "implementation_philosophy"
      }
    },
    {
      "type": "read_files",
      "config": {
        "path": "ai_context/dev_guides/DEV_GUIDE_FOR_{{language | upcase}}.md",
        "content_key": "dev_guide",
        "optional": true
      }
    },
    {
      "type": "llm_generate",
      "config": {
        "prompt": "You are an expert developer...",
        "model": "{{model|default:'openai/o3-mini'}}",
        "output_format": "files",
        "output_key": "generated_files"
      }
    },
    {
      "type": "write_files",
      "config": {
        "root": "{{output_root|default:'output'}}",
        "files_key": "generated_files"
      }
    }
  ]
}
```

This recipe:

1. Reads the implementation philosophy
2. Reads language-specific development guides (if available)
3. Generates code using an LLM
4. Writes the generated files to disk

## The Recipe Executor Itself: A Case Study

The Recipe Executor tool itself was built using the Codebase Generator approach - this is a perfect example of the method in action. The entire codebase, including:

- The context system
- The executor engine
- Step implementations
- LLM integration
- And more

Was generated from recipes and specifications, demonstrating the power and flexibility of this approach.

## The Component Building Recipe

The main component building recipe, found in `recipes/recipe_executor/utils/build_component.json`, shows how a single component is built:

```json
{
  "steps": [
    {
      "type": "read_files",
      "config": {
        "path": "...{{component_id}}/{{component_id}}_spec.md",
        "content_key": "spec"
      }
    },
    {
      "type": "read_files",
      "config": {
        "path": "...{{component_id}}/{{component_id}}_docs.md",
        "content_key": "usage_docs",
        "optional": true
      }
    },
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/codebase_generator/generate_code.json",
        "context_overrides": {
          "model": "{{model|default:'openai/o3-mini'}}",
          "output_root": "{{output_root|default:'output'}}",
          "output_path": "recipe_executor{{component_path}}",
          "language": "{{language|default:'python'}}",
          "spec": "{{spec}}",
          "usage_docs": "{{usage_docs}}",
          "existing_code": "{{existing_code}}"
        }
      }
    }
  ]
}
```

This recipe:

1. Reads the component specification
2. Reads the component usage documentation
3. Executes the code generation recipe with appropriate context

## Implementation Philosophy

The code generation is guided by a core implementation philosophy that emphasizes:

1. **Ruthless Simplicity**: Keep everything as simple as possible
2. **Architectural Integrity with Minimal Implementation**: Preserve key architectural patterns with lightweight implementations
3. **Library Usage Philosophy**: Use libraries as intended with minimal wrappers
4. **Vertical Slices**: Implement complete end-to-end functionality

This philosophy ensures the generated code is clean, maintainable, and focused on solving the problem at hand without unnecessary complexity.

## Using the Codebase Generator

### Prerequisites

1. A working Recipe Executor installation
2. API keys for the LLM provider of your choice
3. Component specifications and documentation

### Directory Structure

For a new project, set up the following structure:

```
my_project/
├── ai_context/
│   ├── IMPLEMENTATION_PHILOSOPHY.md
│   └── dev_guides/
│       └── DEV_GUIDE_FOR_PYTHON.md
├── recipes/
│   ├── codebase_generator/
│   │   └── generate_code.json
│   └── my_project/
│       ├── components/
│       │   ├── component_a/
│       │   │   ├── component_a_spec.md
│       │   │   └── component_a_docs.md
│       │   └── component_b/
│       │       ├── component_b_spec.md
│       │       └── component_b_docs.md
│       ├── create.json
│       └── utils/
│           └── build_component.json
└── output/
    └── my_project/
```

### Creating Component Specifications

Write specifications that clearly describe:

- The component's purpose
- Core requirements
- Implementation considerations
- Component dependencies
- Error handling
- Future considerations

Example specification format:

```markdown
# Component A Specification

## Purpose

Describe what this component does and why it exists.

## Core Requirements

- List key requirements
- Be specific about functionality
- Define constraints

## Implementation Considerations

- Suggest implementation approaches
- Highlight important design decisions
- Note key algorithms or patterns to use

## Component Dependencies

### Internal Components

- List other components this one depends on

### External Libraries

- List external dependencies with versions

## Error Handling

- Define expected error cases
- Specify how errors should be handled

## Output Files

- List expected output files
- Describe file formats or structures

## Future Considerations

- Note potential future enhancements
- Mention known limitations
```

### Creating Component Documentation

Create usage documentation that explains:

- How to import the component
- Basic usage patterns
- API reference
- Examples
- Common use cases

Example documentation format:

````markdown
# Component A Usage

## Importing

```python
from my_project.component_a import ComponentA
```
````

## Basic Usage

Describe how to use the component with simple examples.

## API Reference

Document public methods, classes, and properties.

## Examples

Provide complete examples of common scenarios.

## Important Notes

List any caveats, limitations, or best practices.

````

### Building the Project

1. Create a main recipe that builds all components

```json
{
  "steps": [
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/my_project/components/component_a/component_a_create.json"
      }
    },
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/my_project/components/component_b/component_b_create.json"
      }
    }
  ]
}
````

2. Create individual component build recipes

```json
{
  "steps": [
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/my_project/utils/build_component.json",
        "context_overrides": {
          "component_id": "component_a",
          "component_path": "/components",
          "model": "openai/o3-mini"
        }
      }
    }
  ]
}
```

3. Run the main build recipe

```bash
python -m recipe_executor.main recipes/my_project/create.json
```

## Advanced Techniques

### Parallel Component Generation

Generate multiple components simultaneously:

```json
{
  "steps": [
    {
      "type": "parallel",
      "config": {
        "substeps": [
          {
            "type": "execute_recipe",
            "config": {
              "recipe_path": "recipes/my_project/components/component_a/component_a_create.json"
            }
          },
          {
            "type": "execute_recipe",
            "config": {
              "recipe_path": "recipes/my_project/components/component_b/component_b_create.json"
            }
          }
        ],
        "max_concurrency": 2
      }
    }
  ]
}
```

### Editing Existing Components

For iterative development, create edit recipes that pass the existing code:

```json
{
  "steps": [
    {
      "type": "read_files",
      "config": {
        "path": "output/my_project/components/component_a.py",
        "content_key": "existing_code"
      }
    },
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/my_project/utils/build_component.json",
        "context_overrides": {
          "component_id": "component_a",
          "component_path": "/components",
          "existing_code": "{{existing_code}}"
        }
      }
    }
  ]
}
```

### Human-in-the-Loop Review

After generating code, add a human review step:

```json
{
  "steps": [
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/my_project/components/component_a/component_a_create.json"
      }
    },
    {
      "type": "execute_recipe",
      "config": {
        "recipe_path": "recipes/review_code.json",
        "context_overrides": {
          "component_id": "component_a"
        }
      }
    }
  ]
}
```

## Best Practices

1. **Detailed Specifications**: Write clear, detailed specifications that capture all requirements
2. **Component Boundaries**: Define clean interfaces between components
3. **Consistent Documentation**: Maintain consistent documentation formats across components
4. **Version Control**: Store specifications and recipes in version control, not just the generated code
5. **Iterative Development**: Start with a minimal implementation and iterate based on feedback
6. **Testing**: Include test expectations in your specifications

## Human Role: Architecture and Quality Assurance

In this approach, humans focus on:

1. Designing the overall architecture
2. Writing detailed specifications
3. Reviewing generated code
4. Testing and validation
5. Iterative refinement of specifications

As described in the modular design philosophy:

> In this approach, humans step back from being code mechanics and instead take on the role of architects and quality inspectors. Much like a master builder, a human defines the vision and specifications up front — the blueprint for what needs to be built.

## Conclusion

The Codebase Generator approach leverages the Recipe Executor tool to transform how software is built. By treating code as something to be generated from specifications rather than written line-by-line, it enables:

1. Faster development cycles
2. More consistent implementation
3. Better separation of concerns
4. The ability to experiment with multiple implementations in parallel

The Recipe Executor tool itself stands as proof of this approach's effectiveness - a sophisticated software system built through its own methodology. By following the patterns and practices outlined in this guide, you can apply this same approach to your own software projects.
