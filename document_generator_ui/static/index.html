<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Generator UI</title>
  <style>
    /* Full-height layout */
    html, body { height: 100%; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', Tahoma, sans-serif; margin: 20px; color: #333; }
    h1 { margin-bottom: 10px; }
    h2 { margin-top: 20px; color: #555; }
    input, textarea, select, button { box-sizing: border-box; font-size: 14px; }
    button { background-color: #007bff; color: #fff; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; }
    button:hover { background-color: #0056b3; }
    textarea { font-family: monospace; resize: vertical; }
    .panel { border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #fdfdfd; margin-bottom: 20px; }
    .container { display: grid; grid-template-columns: 300px 1fr 300px; gap: 20px; height: calc(100vh - 40px); }
    .document-view, .work-view, .controls-view { padding: 10px; overflow: auto; }
    .work-view { display: flex; flex-direction: column; }
    .work-view details { flex: 1 1 auto; overflow: auto; margin-bottom: 10px; }
    textarea#outlineJson { width: 100%; flex: 1 1 auto; resize: vertical; }
    #runLog { background: #000; color: #0f0; font-family: monospace; overflow-y: auto; white-space: pre-wrap; word-break: break-all; padding: 10px; border-radius: 4px; height: 200px; margin-top: 10px; }
    #resourceList li, #sectionTree div { margin: 4px 0; }
  </style>
</head>
<body>
  <h1>Document Generator UI</h1>
  <div class="container">
    <!-- Left: Document and Sections -->
    <div class="panel document-view">
      <h2>Document</h2>
      <label for="docTitle">Title:</label><br>
      <input type="text" id="docTitle" placeholder="Document title"><br><br>
      <label for="generalInstruction">General Instruction:</label><br>
      <textarea id="generalInstruction" placeholder="General instruction"></textarea><br><br>
      <h3>Sections</h3>
      <button id="addSection">Add Section</button>
      <div id="sectionTree"></div>
    </div>
    <!-- Center: Editing & Logs -->
    <div class="panel work-view">
      <h2>Section Editor</h2>
      <div id="sectionEditor"></div>
      <details open>
        <summary>Raw Outline JSON</summary>
        <textarea id="outlineJson" style="width:100%;height:150px;" placeholder="Raw outline JSON"></textarea>
      </details>
      <h2>Logs</h2>
      <pre id="runLog"></pre>
    </div>
    <!-- Right: Controls & Resources -->
    <div class="panel controls-view">
      <h2>Outline Controls</h2>
      <button id="loadOutline">Load Outline</button>
      <button id="saveOutline">Save Outline</button>
      <h2>Resources</h2>
      <input type="file" id="uploadFile" />
      <button id="uploadBtn">Upload Resource</button>
      <ul id="resourceList"></ul>
      <h2>Generate</h2>
      <button id="runBtn">Generate</button>
      <a id="downloadLink" style="display:none; margin-left:10px;">Download Document</a>
    </div>
  </div>
  <script>
    // Remove references to a deleted resource from sections
    function pruneDeletedResource(key) {
      function recurse(sections) {
        sections.forEach(sec => {
          if (sec.resource_key === key) sec.resource_key = null;
          if (Array.isArray(sec.refs)) sec.refs = sec.refs.filter(r => r !== key);
          if (Array.isArray(sec.sections) && sec.sections.length) recurse(sec.sections);
        });
      }
      if (outlineData && Array.isArray(outlineData.sections)) {
        recurse(outlineData.sections);
      }
    }
    // Render the Document Metadata inputs from outlineData
    function renderOutlineMeta() {
      const titleInput = document.getElementById('docTitle');
      const genInput = document.getElementById('generalInstruction');
      if (outlineData) {
        titleInput.value = outlineData.title || '';
        genInput.value = outlineData.general_instruction || '';
      }
    }
    let outlineData = null;
    let selectedSectionIndex = null;
    function renderSectionTree() {
      const tree = document.getElementById('sectionTree');
      tree.innerHTML = '';
      if (!outlineData || !Array.isArray(outlineData.sections)) {
        renderSectionEditor();
        return;
      }
      outlineData.sections.forEach((sec, idx) => {
        const item = document.createElement('div');
        item.style.marginLeft = '0px';
        item.style.padding = '4px';
        if (idx === selectedSectionIndex) {
          item.style.backgroundColor = '#eef';
        }
        const titleSpan = document.createElement('span');
        titleSpan.textContent = sec.title || '(no title)';
        titleSpan.style.cursor = 'pointer';
        titleSpan.onclick = () => {
          selectedSectionIndex = idx;
          renderSectionTree();
        };
        item.appendChild(titleSpan);
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.style.marginLeft = '8px';
        delBtn.onclick = () => {
          outlineData.sections.splice(idx, 1);
          document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
          if (selectedSectionIndex === idx) selectedSectionIndex = null;
          renderSectionTree();
        };
        item.appendChild(delBtn);
        tree.appendChild(item);
      });
      renderSectionEditor();
    }
    async function loadOutline() {
      try {
        const resp = await fetch('/api/outline');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        outlineData = data;
        // Render metadata inputs from outlineData
        if (typeof renderOutlineMeta === 'function') renderOutlineMeta();
        // Ensure all sections have a refs array
        if (Array.isArray(outlineData.sections)) {
          outlineData.sections.forEach(sec => {
            if (!Array.isArray(sec.refs)) sec.refs = [];
          });
        }
        // Load and sync resources
        if (typeof loadResources === 'function') await loadResources();
        document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
        selectedSectionIndex = null;
        renderSectionTree();
      } catch (e) {
        alert('Failed to load outline: ' + e);
        console.error(e);
      }
    }

    async function saveOutline() {
      try {
        const text = document.getElementById('outlineJson').value;
        let jsonData;
        try {
          jsonData = JSON.parse(text);
        } catch (err) {
          alert('Invalid JSON: ' + err);
          return;
        }
        const resp = await fetch('/api/outline', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(jsonData)
        });
        if (!resp.ok) {
          const body = await resp.text();
          throw new Error(body || `HTTP ${resp.status}`);
        }
        alert('Outline saved successfully.');
      } catch (e) {
        alert('Failed to save outline: ' + e);
        console.error(e);
      }
    }

    document.getElementById('loadOutline').addEventListener('click', loadOutline);
    document.getElementById('saveOutline').addEventListener('click', saveOutline);
    document.getElementById('addSection').addEventListener('click', () => {
      if (!outlineData) {
        alert('Load an outline first');
        return;
      }
      const title = prompt('New section title:');
      if (title !== null) {
        const newSection = {
          id: Date.now().toString(),
          title,
          prompt: '',
          resource_key: null,
          refs: [],
          sections: []
        };
        outlineData.sections.push(newSection);
        document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
        selectedSectionIndex = outlineData.sections.length - 1;
        renderSectionTree();
      }
    });
    // Metadata inputs: update outlineData on change
    document.getElementById('docTitle').addEventListener('change', e => {
      if (!outlineData) return;
      outlineData.title = e.target.value;
      document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
    });
    document.getElementById('generalInstruction').addEventListener('change', e => {
      if (!outlineData) return;
      outlineData.general_instruction = e.target.value;
      document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
    });
    console.log('Document Generator UI loaded (v4)');
    
    function renderSectionEditor() {
      const editor = document.getElementById('sectionEditor');
      editor.innerHTML = '';
      if (selectedSectionIndex == null || !outlineData || !outlineData.sections[selectedSectionIndex]) return;
      const sec = outlineData.sections[selectedSectionIndex];
      // Title input
      const titleLabel = document.createElement('label');
      titleLabel.textContent = 'Title:';
      const titleInput = document.createElement('input');
      titleInput.style.width = '100%';
      titleInput.value = sec.title || '';
      titleInput.onchange = e => {
        sec.title = e.target.value;
        document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
        renderSectionTree();
      };
      editor.appendChild(titleLabel);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(titleInput);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(document.createElement('br'));
      // Prompt textarea (disabled when a content resource is selected)
      const promptLabel = document.createElement('label');
      promptLabel.textContent = 'Prompt:';
      const promptArea = document.createElement('textarea');
      promptArea.style.width = '100%';
      promptArea.style.height = '100px';
      promptArea.value = sec.prompt || '';
      // Disable prompt if a content resource is selected
      promptArea.disabled = !!sec.resource_key;
      promptArea.onchange = e => {
        sec.prompt = e.target.value;
        document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
      };
      editor.appendChild(promptLabel);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(promptArea);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(document.createElement('br'));
      // Content Resource select (resource_key): choose a resource whose raw `content` is inserted, matching recipes/write_content.json
      // Content Resource dropdown
      const resourceLabel = document.createElement('label');
      resourceLabel.textContent = 'Content Resource:';
      const resourceSelect = document.createElement('select');
      const noneOpt = document.createElement('option');
      noneOpt.value = '';
      noneOpt.textContent = '(none)';
      resourceSelect.appendChild(noneOpt);
      (outlineData.resources || []).forEach(r => {
        const opt = document.createElement('option');
        opt.value = r.key;
        // Display resource key and filename: prefer original filename if stored, else basename of path
        // Display filename derived from path; r.path always present
        const fname = r.path.split('/').pop() || r.path;
        opt.textContent = `${r.key} (${fname})`;
        if (r.key === sec.resource_key) opt.selected = true;
        resourceSelect.appendChild(opt);
      });
      resourceSelect.onchange = e => {
        const sel = e.target.value || null;
        sec.resource_key = sel;
        // If a content resource is set, clear and disable prompt
        if (sel) {
          sec.prompt = '';
          promptArea.value = '';
          promptArea.disabled = true;
        } else {
          // Re-enable prompt for manual input
          promptArea.disabled = false;
        }
        document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
      };
      editor.appendChild(resourceLabel);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(resourceSelect);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(document.createElement('br'));
      // References multiselect
      const refsLabel = document.createElement('label');
      refsLabel.textContent = 'References:';
      // References multiselect (refs): include these resources as references in the LLM prompt (used in recipes/write_section.json)
      const refsSelect = document.createElement('select');
      refsSelect.multiple = true;
      refsSelect.style.width = '100%';
      (outlineData.resources || []).forEach(r => {
        const opt = document.createElement('option');
        opt.value = r.key;
        // Display resource key and filename for references
        // Display reference filename derived from path
        const fnameRef = r.path.split('/').pop() || r.path;
        opt.textContent = `${r.key} (${fnameRef})`;
        if (Array.isArray(sec.refs) && sec.refs.includes(r.key)) opt.selected = true;
        refsSelect.appendChild(opt);
      });
      refsSelect.onchange = e => {
        sec.refs = Array.from(e.target.selectedOptions).map(o => o.value);
        document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
      };
      editor.appendChild(refsLabel);
      editor.appendChild(document.createElement('br'));
      editor.appendChild(refsSelect);
    }
    // Resource management (v4)
    async function loadResources() {
      try {
        const resp = await fetch('/api/resources');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const resData = await resp.json();
        if (outlineData) {
          outlineData.resources = resData;
          document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
        }
        renderResourceList();
        renderSectionTree();
      } catch (e) {
        console.error('Failed to load resources:', e);
      }
    }
    function renderResourceList() {
      const list = document.getElementById('resourceList');
      list.innerHTML = '';
      if (!outlineData?.resources) return;
      outlineData.resources.forEach(r => {
        const li = document.createElement('li');
        // Display resource key and path (or filename if path missing)
        // Display resource key and filename (basename of path)
        const displayName = r.path ? r.path.split('/').pop() : '';
        li.textContent = `${r.key}: ${displayName}${r.description ? ' - ' + r.description : ''}`;
        const del = document.createElement('button');
        del.textContent = 'Delete';
        del.style.marginLeft = '8px';
        del.onclick = async () => {
          if (!confirm('Delete resource ' + r.key + '?')) return;
          const dr = await fetch(`/api/resource/${r.key}`, { method: 'DELETE' });
          if (!dr.ok) { alert('Delete failed'); return; }
          await loadResources();
          // Remove deleted resource from any section assignments
          pruneDeletedResource(r.key);
          document.getElementById('outlineJson').value = JSON.stringify(outlineData, null, 2);
          renderSectionTree();
        };
        li.appendChild(del);
        list.appendChild(li);
      });
    }
    async function uploadResource() {
      const input = document.getElementById('uploadFile');
      if (!input.files.length) { alert('Select a file'); return; }
      const form = new FormData();
      form.append('file', input.files[0]);
      const resp = await fetch('/api/resource', { method: 'POST', body: form });
      if (!resp.ok) {
        const text = await resp.text();
        alert('Upload failed: ' + text);
        return;
      }
      alert('Upload successful');
      input.value = '';
      await loadResources();
    }
    document.getElementById('uploadBtn').addEventListener('click', uploadResource);
    // v5: Generate document and download (use static elements in the DOM)
    const runLog = document.getElementById('runLog');
    const downloadLink = document.getElementById('downloadLink');
    const runBtn = document.getElementById('runBtn');

    async function runGeneration() {
      runBtn.disabled = true;
      runLog.textContent = '';
      downloadLink.style.display = 'none';
      try {
        const resp = await fetch('/api/run', { method: 'POST' });
        const result = await resp.json();
        if (result.logs) {
          result.logs.forEach(line => runLog.textContent += line + '\n');
        }
        if (result.status === 'ok') {
          downloadLink.href = result.download_url;
          downloadLink.style.display = 'block';
        } else {
          alert('Generation failed: ' + result.error);
        }
      } catch (e) {
        alert('Error during generation: ' + e);
      } finally {
        runBtn.disabled = false;
      }
    }
    runBtn.addEventListener('click', runGeneration);
  </script>
</body>
</html>